# Golang Hexagonal Architecture Example

> This is a simple example of a Golang application using the Hexagonal Architecture.

## 패키지 구조 설명

---

### `cmd`
프로젝트의 메인 어플리케이션이 들어 있는 디렉토리입니다.

### `config`
프로젝트의 설정 파일이 들어 있는 디렉토리입니다.

### `internal`
외부에서 임포트할 수 없는 패키지들이 들어 있는 내부 패키지로 프로젝트의 핵심 로직이 들어 있는 디렉토리입니다.

* `core` : 프로젝트의 핵심 로직이 들어 있는 디렉토리입니다.
  * `domain` : 도메인 모델이 들어 있는 디렉토리입니다.
  * `port` : 포트 인터페이스가 들어 있는 디렉토리입니다.
    * `in` : 인바운드 포트 인터페이스가 들어 있는 디렉토리입니다. ( usecase )
    * `out` : 아웃바운드 포트 인터페이스가 들어 있는 디렉토리입니다. ( repository )
  * `usecase` : 유스케이스 로직이 들어 있는 디렉토리입니다.
* `adapter` : 외부와의 연결을 위한 어댑터가 들어 있는 디렉토리입니다.
  * `in` : 인바운드 어댑터가 들어 있는 디렉토리입니다.
    * `handler` : gin 핸들러가 들어 있는 디렉토리입니다.
      * `request` : 요청 핸들러 모델이 들어 있는 디렉토리입니다.
      * `response` : 응답 핸들러 모델이 들어 있는 디렉토리입니다.
  * `out` : 아웃바운드 어댑터가 들어 있는 디렉토리입니다.
    * `repository` : 레포지토리 어댑터가 들어 있는 디렉토리입니다.
      * `entity` : 레포지토리 엔티티 모델이 들어 있는 디렉토리입니다.
* `pkg` : 프로젝트 전반적으로 사용되는 패키지가 들어 있는 디렉토리입니다.

### 계층간 모델 매핑 전략
> 각 매핑 전략은 저마다 장단점을 가지고 있기 때문에 유연한 매핑 구조의 사용을 권장합니다. <br>
> 유연한 매핑 구조의 사용을 위해 `model` 패키지를 별도로 구성하여 계층간 모델 매핑 전략을 선택적으로 사용할 수 있습니다. <br>

**매핑하지 않기**
> `port` 인터페이스가 `model/domain` 패키지의 모델을 입출력 모델로 사용하여 계층간 매핑을 할 필요 없게 만든다.

* 장점: 매핑 코드가 필요 없어서 불필요한 보일러플레이트 코드를 줄일 수 있다.
* 단점: 모든 계층이 동일한 모델을 사용하기 때문에 계층간 강한 결합이 발생하고 단일책임원칙을 위반한다.
* 간단한 CRUD 와 같이 모든 계층이 정확히 같은 구조와 정보를 필요로 한다면 사용 가능하다. 굳이 필요하지 않다면 `양방향 매핑 전략`과 같은 방식으로 over-engineering 하지 않는다.

**양방향 매핑 전략**
> 각 어댑터가 전용 모델을 가지고 있어 어댑터 모델을 도메인 모델로, 도메인 모델을 어댑터의 모델로 매핑할 책임을 가진다. <br>
> port 인터페이스는 `model/domain` 의 모델을 사용하고, 어댑터는 `model/handler`, `model/repository` 의 모델을 사용한다.

* 장점: 각 계층별 모델은 단일책임원칙을 만족한다.
* 단점: 두 모델간 매핑을 구현하는데 많은 보일러플레이트 코드가 생긴다.
